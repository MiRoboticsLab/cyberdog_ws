# <center>cyberdog_bringup 设计文档</center>

## <font color=Blue size=4> 目录 </font>
* [1. 修订](#1-修订)
* [2. 概述](#2-概述)
* [3. 设计](#3-设计)
    * [3.1. 功能设计](#31-功能设计)
    * [3.2. 模块设计](#32-模块设计)
---
## 1. 修订

<center>

项目|软件版本|协议版本|修订日期|修订人员|备注
:--:|:--|:--|:--:|:--:|:--:
启动|V1.1.0.0|V1.0.0.0|2023-02-06|尚子涵|无

</center>

## 2. 概述
bringup 主要功能如下：
1. 可根据目标配置文件（*.yaml）内的参数启动机器人内所有已配置的节点；
2. 动态启动/停止某些节点（目前仅 navigation2 有需求）；
3. 配置文件尽可能全的适配 ROS2 launch 内接口；

## 3. 设计
### 3.1. 功能设计
bringup 启动约束分两类，即配置文件（*.yaml）和 命令行启动参数（argv[]），其中：
1. 配置文件（*.yaml）有唯一主文件，主文件内可加载其他副文件内符合 ros 约束的参数；
2. 命令行启动参数（argv[]）适配 ROS2 launch 参数接口。

就启动文件呈现形式考虑到以下问题：
1. 启动约束在运行时动态加载到内存时用户不可见，不好排查分析；
2. 唯一启动文件不可以同时启动多次，不好排查分析。

故启动约束将静态穷举，尽可能避免运行时动态加载，由此：
1. 启动文件将在 cyberdog_bringup 编译时根据配置文件（*.yaml）动态生成；
2. 且尽可能穷举参数，但也会流出动态参数入口。
3. 启动文件有唯一主文件，负责启动参数约束下所有节点；
4. 启动文件有不同级别的副文件，负责启动参数约束下相应节点。

#### 3.2 模块设计

<center>

![](./image/cyberdog_bringup.svg)

</center>

- cyberdog_bringup根据配置文件（bringup.yaml, launch.yaml, node.yaml）动态生成所需的各级别的launch.py 文件。
- 自动生成的launch.py文件会根据配置参数加载手动创建的 yaml 文件或 launch 文件，做到灵活配置。
- 最终根据配置可实现启动机器人所有节点的唯一 launch.py，用于系统级别的service 调用，从而实现机器人软件功能的自动启动功能。

实现方案简单分为以下5步：
1. 将复杂冗长的语法进行分类抽象，提取出必须由人工编码的环节并高度抽象为自定义的元语言；
2. 用某种编码风格（比如toml，yaml，json等）对自定义元语言进行编码；
3. 为上述确定的编码风格及元语言编写编译工具，也就是机器人实现自动编码功能的程序；
4. 在每次编译时，自动对元语言进行编译，产生可执行脚本，并安装；
5. 通过系统指令设置开机启动。


